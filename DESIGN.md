# MKID Gen3 Firmware Design

A Note: We suggest starting from [mkidgen3](https://github.com/MazinLab/MKIDGen3) if you are looking at this project for the first time. This repository is for the gateware and some associated test utilities. This document and project are in heavy flux and resource calculations are only partially done. Some linked projects do not yet exist or are untested (especially in the timekeeping/triggering area of the design) and the names and links are suggestive placeholders. In some cases there are alternative/backup approaches that are not described. The principal authors welcome and encourage email inquiry. 



***See `readme.md` for information on how to create a vivado project of the design and how to get started.***

The overall design is composed of a few subsystems:
- Plumbing: Control, Resets, Clocks, the RFDC, and the SoC interface
- Frequency Comb Generation
- Photon Pipeline: Raw data processing
- Capture: Raw and intermediate data capture


# Plumbing

### Clocks
1. 128 MHz clk_adc1. Used for control of axilite and generating 512 MHz clock. From ADC PLL.
2. 256 MHz clk_dac. Used for the dac_replay block. From the DAC PLL
3. 512 MHz pipeline clock. Generated by an MMCM in a clock wizard from the 128 MHz clock.
4. 256 MHz capture clock. Generated by an MMCM in a clock wizard from the 128 MHz clock.
5. 333 MHz DDR4 clock. Used to read/write from the PL DDR4. Generated by the MIG.

### Resets
Tied off for most of the design. The RFDC and the dac_replay blocks require them for proper functionality. The resets hierarchy contains all the processor resets and nearly all the constants used for resets in the design. 

### RF Data Converter Block
Two ADCs 
Detailed configuration of this block is TBD and handled from PYNQ. 

### Control

### SoC Interface


# Frequency Comb Generation
The comb is computed in python using repackaged code from gen2 on a per-feedline basis. The comb, as a 2x8x2^15 element LUT, is loaded as signed shorts into the [DAC 
Replay core](https://github.com/MazinLab/dac-replay-ip).

## DAC Replay Core
HLS (`#pragma HLS INTERFACE s_axilite port=return bundle=control`) with an AXI4 Master, three AXIS Masters, and a few axilite control params. Clocked directly from RFDC clk_dac1 output @ 256 MHZ. Uses 60 URAMS for up to 2MiB of replay buffer.

The core has two loops, the first fetches and fills the replay buffer. The second pipelined with an II=1, runs as long as the run bit is set, replaying the from the buffer with whatever settings the core was started with. 

AXI4M:
 - Issues 128b reads directly to PS DDR via S_AXI_HP0_FPD @ 256MHz

AXIS:
- I to DAC10 (256b)
- Q to DAC11 (256b)
- IQ words with TUSER and TLAST for debugging (512,8,1b)


# Photon Processing Pipeline
The readout subsystem is significantly more complicated than the comb generator. It consists of an oversampled polyphase filter bank (OPFB), followed by resonator channel selection, direct digital down conversion, low-pass filtering, iq->phase conversion, and optimal filtering. Even triggering, estimation,  and capture (both event and dbug) are considered different subsystems. Presently the design is roughly complete through the optimal filtering stage, though significant DSP testing remains. 

![](./img/photonpipe.png)

Within the `photon_pipe` hierarchy data flows from the ADCs as follows:
- opfb/
  1. [adc-to-opfb](https://github.com/MazinLab/adc-to-opfb)
  2. Xilinx FIR Compiler Cores 256 channel 2 parallel path mode (configured by [opfb-fir-config](https://github.com/MazinLab/opfb-fit-config))
  3. [opfb-fir-to-fft](https://github.com/MazinLab/opfb-fir-to-fft)
  4. Xilinx SSR (Vector) FFT, packaged and exported from ModelComposer (MazinLab_mkidgen3_ssrfft_16x4096_axis_v1_0)
  5. [pkg-fft-output](https://github.com/MazinLab/pkg-fft-output)
- reschan/
  1. [opfb-bin-to-res](https://github.com/MazinLab/opfb-bin-to-res)
  2. [resonator-dds](https://github.com/MazinLab/resonator-dds)
  3. Xilinx FIR Compiler in 256 channel 2 parallel path mode (static TDM lopass filter)
- phase/
  1. Xilinx Data width converter
  2. Xilinx Cordics
  3. [phase-user-attach](https://github.com/MazinLab/phase-user-attach)
- phasematch/
  1. Xilinx FIR Compiler Cores in 512 channel mode
  2. Coefficient reload subsystem comprising
    - AXI-Stream FIFO
    - AXI4S Data Width converter
    - AXI4S Clock Converter
    - AXI4S Switch
- trigger/
  1. [photon-trigger](https://github.com/MazinLab/photon-trigger)
  2. [photon-writer](https://github.com/MazinLab/XXXXX)
  3. [postage-stamp-monitor](https://github.com/MazinLab/XXXXX)
  4. Xilinx AXI4S clock converters,
  5. axis2mm cores
  6. Xilinx AXI4S data FIFO
  7. A Xilinx SmartConnect

AXI Interconnects, AXI4S broadcasters, combiners, and register slices are omitted here but scattered liberally throughout.


## Overlapped Polyphase Filter
The photon_pipe.opfb hierarchy ingests the raw data stream each ADC (one I, one Q) and yields an IQ stream of Overlapped Polyphase filter channels, each with 2 MHz of bandwidth.The OPFB runs at 512~Mhz, has no control lines, and has its reset tied off. Within in the hierarchy data flows through the HLS [adc-to-opfb](https://github.com/MazinLab/adc-to-opfb) block (dataflow, 2 functions, all ap_ctrl_none), then into the fir hierarchy where it is sliced/broadcast into bank of 16 FIR Compiler blocks configured by a small HLS coefficient select block ([opfb-fir-cfg](https://github.com/MazinLab/opfb-fir-cfg)) that runs once when the bitstream is loaded. 

The FIR outputs are merged with an axis combiner, fed through the [opfb-fir-to-fft](https://github.com/MazinLab/opfb-fir-to-fft) HLS block for processing (pipeline ii=1, flat, ap_ctrl_none), to an axis broadcast/slice, and into a super sample rate 4096 point FFT block exported from sysgen (16x256). The output of the FFT is packaged back into a single AXIS stream by [pkg-fft-output](https://github.com/MazinLab/pkg-fft-output) (pipeline ii=1, flat, ap_ctrl_none, ap_vld on the inputs). This last block generates the TLAST signal from an internal counter.

#### In:
- 256b AXI4S of 8 16b signed I words @ 512MHz
- 256b AXI4S of 8 16b signed Q words @ 512MHz
- aresetn
- clock, 512MHz, synchronous to the ADC I & Q datastreams

#### Out:
- 512b AXI4S of 16 32b signed IQ equipped with TUSER (16b, the 12b fft scale output) and TLAST every 256 transactions, any backpressure is ignored. 


#### Hierarchy:
- adc_to_opfb
- firs/
  - broadcast w/ slice
  - firs (w/ fft_config)
  - combiner
- fir_to_fft
- fft/
  - broadcast w/ slice
  - SSR FFT (4096 16x256)
  - pkg_fft_output

#### Utilization:
TODO


### adc-to-opfb
```cpp
void adc_to_opfb( hls::stream<ap_uint<128>> &istream, hls::stream<ap_uint<128>> &qstream, hls::stream<ap_axiu<512,0,0,0>> &lanes) {
#pragma HLS DATAFLOW
#pragma HLS INTERFACE axis register port=istream
#pragma HLS INTERFACE axis register port=qstream
#pragma HLS INTERFACE axis register port=lanes
#pragma HLS INTERFACE ap_ctrl_none port=return
// ...
```

#### In: 
- I Stream 128b AXI4S of 8 16b signed words
- Q Stream 128b AXI4S of 8 16b signed words

#### Out:
- Interleaved IQ Stream 512b AXI4S of 16 32b complex signed words, stream equipped with TLAST that asserts every 512 beats.

This block takes the incoming 8 I & Q samples and bundles them into uint256 groups of 8 complex words for internal operations. It breaks the 8 IQ into 16 by applying feeding the even and odd lanes with every other sample (i.e. sample 0, 16, 32 -> 
lane0; 8, 24, 40 -> lane1; sample 1, 17, 33 -> lane2; etc). Two delay lines 128 samples and uses the
delay line to drive the output in 'off' cycles, thereby resulting in output with sample indices like 0, -127, 1, -126, ... for a given lane. The resulting pattern may be seen in full, along with the intended FIR coefficient set (TODO) for
multiplication in the simulation output. TLAST is set on the 512th cycle. 

### FIR Compiler Bank
The interleaved IQ stream for *adc_to_opfb* is split into 16 single IQ streams via a broadcaster with each sent into one of 16 FIR Compiler cores. The broadcaster has TREADY disabled. 

The 16 FIRs are configured for 512 channel 2 parallel path 16 bit input, 16 bit output with 256 coefficient sets. Configuration is by channel and done by the [opfb-fir-cfg](https://github.com/MazinLab/opfb-fir-cfg) block sending coefficient set order as 0, 0, 1, 1, 2, 2, ... via a broadcaster. Coefficient reload is disabled. The FIRs are configured for vector framing with no TUSER input or output and no TREADY support. 

The output is remerged into a single stream via an axi4s combiner. 

### opfb-fir-to-fft
```cpp
void fir_to_fft(hls::stream<ap_axiu<512, 0,0,0>> &input, hls::stream<ap_axiu<512, 0,0,0>> &output) {
#pragma HLS PIPELINE II=1
#pragma HLS INTERFACE axis register port=input
#pragma HLS INTERFACE axis register port=output
#pragma HLS INTERFACE ap_ctrl_none port=return
// ...
```

#### In:
- Interleaved IQ Stream 512b AXI4S of 16 32b complex signed words, stream equipped with TLAST that asserts every 512 beats.
#### Out:
- Interleaved IQ Stream 512b AXI4S of 16 32b complex signed words, stream equipped with TLAST that asserts every 512 beats.

This block takes the merged IQ stream from the FIR bank and reorders them as needed to feed the FFT. The stream is broken into even (group A) and odd samples, with odd samples grouped into a group of the first 128 (group B) and second 128 (group C). Samples are stored in internal FIFOs and sent on in order from group A, then C, then B, thereby achieving the alternating cycle reorder required by the OPFB. The resulting index order from this are available from the C simulation of the core.


### Vector (SSR) FFT
#### In: 
- 16 IQ 32b AXI4S streams of complex signed words. Side channels are ignored. TREADY is permanently asserted. 
- 12b Scale Port

#### Out: 
- 16x 32b output ports of of complex signed words and an output valid line.
- 12b overflow port

The FFT is done by the Xilinx Vector FFT from the SSR Blockset for System Generator/Model Composer. The inputs into the FFT must be connected in an interleaved fashion to ensure the expected natural bin order. The first 8 inputs coming from the even lanes and the second 8 inputs from the odd lanes. This order is ensured by the preceeding blocks in the design. The HLS SSR FFT is not used as of HLx 2019.2 as there were both windows/linux compile issues and initial tests showed it may not make timing.


### pkg-fft-output 
```cpp
void pkg_fft_output(unsigned int iq[N_LANES], scale_t scale, hls::stream<ap_axiu<512,16,0,0>> &output) {
#pragma HLS INTERFACE ap_vld port=iq
#pragma HLS INTERFACE ap_vld port=scale
#pragma HLS INTERFACE axis register forward port=output
#pragma HLS ARRAY_PARTITION variable=iq type=complete
#pragma HLS PIPELINE II=1
#pragma HLS INTERFACE ap_ctrl_none port=return
\\...
```

#### In: 
- 16x 32b ports of complex signed IQ words and associated valid lines
- 12b scale overflow port

#### Out: 
- 512b AXI4S stream of 16 32b complex signed IQ words equipped with TLAST and TUSER.

This block ingests the SSR FFT output and packages it into a single wide axis stream. Any backpressure applied to this core WILL cause the OPFB output stream to irreparably lose synchronization, **it is therefore advised to explicitly tie TREADY high**. TUSER contains the overflow status of the SSR FFT. TLAST is asserted every 256th beat, indicating the beat of the last OPFB bin in a full spectrum


## Resonator Channelization
The resonator channelization stage creates a resonator channel axi4s stream of 2048 IQ streams, grouped in 8s and temporallly muxed from the stream of 4096 FFT IQ bins. It digitally down-converts on a per-channel basis, low-pass filters, and decimates (2:1) each. The result is 2048 resonator channels with . Selection is done by [bin-to-res](https://github.com/MazinLab/bin-to-res), DDC by the [resonator-ddc](https://github.com/MazinLab/resonator-dds) (git repo is a misnomer, TODO) block, and filtering+decimationn by an FIR Compiler core. At present this FIR core is one of the largest resource offenders of the entire design even though its purpose it to merely prevent phase wraps, be ~3dB flat in 500 kHz, and move from a 2MHz to 1MHz sample rate.   

#### Hierarchy: 
1. [bin-to-res](https://github.com/MazinLab/bin-to-res)
2. broadcast to debug capture
3. [resonator-ddc](https://github.com/MazinLab/resonator-dds)
4. broadcast to debug capture
5. Xilinx FIR Compiler Core, 256 channel 16 parallel path mode, single coefficient set
6. broadcast to debug capture

#### In:
- 512b AXI4S of 16 32b complex numbers, with TLAST indicating beat containing final OPFB bin
- AXI-Lite Control Port
- aresetn 
- clock, 512MHz, synchronous to the ADC I & Q datastreams

#### Out:
- 256b AXI4S of 8 16b complex, with TLAST, TUSER (group), valid every other clock (256MHz data @ 512MHz)
- AXI4S debug streams for capturing raw ADC IQ and DDCd IQs

#### Utilization:
TODO

### bin-to-res
```cpp
void bin_to_res(hls::stream<ap_axiu<512,0,0,0>> &iq_stream, hls::stream<ap_axiu<256,8,0,0>> &res_stream, ap_uint<12*N_RES_PCLK> rid_to_bin[256]) {
#pragma HLS PIPELINE II=1 style=frp
#pragma HLS INTERFACE axis register port=iq_stream
#pragma HLS INTERFACE axis register port=res_stream
#pragma HLS INTERFACE s_axilite port=rid_to_bin name=resmap bundle=control
#pragma HLS INTERFACE ap_ctrl_none port=return
\\...
```

#### In:
- 512b AXI4S of 16 32b complex IQ words, equipped with TLAST
- AXI-Lite resonator channel to OPFB bin mapping port, an ap_uint<12*8> 256 element array

#### Out:
- 256b AXI4S of 8 32b complex IQ words, equipped with TLAST and TUSER

[Bin-to-res](https://github.com/MazinLab/opfb-bin-to-res) ingests the IQ bins output by the
OPFB subsystem and caches them into eight identical independent caches consisting of one full 4096 point OPFB spectrum each. It extracts 8 cached IQ values per the mapping each beat, combining these and outputting as a single TDM stream of the corresponding to resonators. Caches are implemented as 8 banks of ~131kb BRAMs in order to have sufficient memory ports. The bin mapping is a 96b x 256 entry LUT loaded in from python via AXI Lite. Each 96b word specifies the 8 OPFB bin addresses used to drive the resonator channels of the corresponding group, e.g. bits 12-23 of word 2 specify the OPFB bin for resonator channel 17 (8*2+1). 

TLAST is asserted every 256th beat and TUSER contains the group number. For any beat the resonator channels on TDATA are 8*TUSER to 8*(TUSER+1)-1, least to most significant bit. The cache write address is reset to 0 every inbound TLAST to ensure that should the core ever stall due to backpressure the resonator outputs will be out of sync for at most one full OPFB spectrum.

### resonator-ddc
```cpp
#define N_TONEBITS 11
#define N_P0BITS 21

typedef struct tone_t {
  ap_fixed<N_TONEBITS, 1, AP_RND_CONV, AP_WRAP> inc;
  ap_fixed<N_P0BITS, 1, AP_RND_CONV, AP_WRAP> phase0; //-1-1 wrap
} tone_t;

typedef ap_uint<(N_P0BITS+N_TONEBITS)*N_RES_PCLK> tonegroup_t;  // 8 tone_t

void resonator_dds(hls::stream<ap_axiu<256,8,0,0>> &res_in, hls::stream<ap_axiu<256,8,0,0>> &res_out, tonegroup_t tones[N_RES_GROUPS]) {
#pragma HLS INTERFACE ap_ctrl_none port=return
#pragma HLS INTERFACE s_axilite port=tones
#pragma HLS INTERFACE axis port=res_in register
#pragma HLS INTERFACE axis port=res_out register
#pragma HLS PIPELINE II=1
\\...
```

#### In:                 
- 256b AXI4S of 8 32b complex IQ equipped with TLAST and TUSER
  - The core treats IQ values as equivalent to `complex<ap_fixed<16, -9, AP_RND_CONV, AP_SAT_SYM>>`
- AXI-Lite Control Port for DDC tone control LUT

#### Out:
- 256b AXI4S of 8 32b complex IQ (down-converted) equipped with TLAST and TUSER
  - Values are packed as equivalent to `complex<ap_fixed<16, -7, AP_RND_CONV, AP_SAT_SYM>>`

The [resonator-ddc](https://github.com/MazinLab/resonator-dds) core maintains an internal phase accumulator for each resonator channel, incrementing it by the channel's tone increment and offsetting it by the channel's phase offset (rotate loops in lab parlance). The accumulator value is then used to query a quarter-wave sin/cos LUTs stored in with the core ROM. The result is neither dithered nor Taylor corrected, though there is example Xilinx HLS code for how to implement those features. The resulting sin/cos values are fed into a Xilinx complex multiplier (3 DSP slices per IQ, 24 in total) and the results passed out of the block. The tone LUT consists of packed tone increments `ap_fixed<N_TONEBITS, 1, AP_RND_CONV, AP_WRAP>` and offsets `ap_fixed<N_P0BITS, 1, AP_RND_CONV, AP_WRAP>`. The python driver and helpers in `mkidgen3.drivers.ddc.DDC.tones` and `mkidgen3.configure_ddc` have details. 

**Because this core uses an internal stream counter in its present form it is not robust to back-pressure**. Switching to a counter that resets on inbound TLAST or no counter and use of TUSER would both alleviate this issue but have timing and structure implications that would need to be tested.

### FIR Compiler Core
The low-pass FIR is configured for 256 channel, 16 parallel channel (8I, 8Q) operation with 20 taps and 16b sample width. It is configured for a decimation of 2, dropping the sample rate to 1 MHZ. This core is a significant fraction of the entire designs utilization.

## Phase
The phase subsystem uses a bank of 4 Xilinx Cordic blocks in between an axis broadcaster and combiner.

#### Hierarchy: 
1. data width converter
2. broadcast to 4 substreams
3. 4x Xilinx Cordic cores in arctan mode
4. axis combiner
5. [attach_user]((https://github.com/MazinLab/phase-user-attach) 

#### In:
- 256b AXI4S of 8 32b complex numbers valid every other clock (256MHz data @ 512MHz)
- aresetn 
- clock, 512MHz, synchronous to the ADC I & Q datastreams

#### Out:
- 64b AXI4S of 4 16b phases, with TLAST and TUSER (group)

#### Utilization:
TODO


## Phasematch
The FIR is configured for 256 channel operation with 51 taps for 256 reloadable coefficient sets and 18 bit IO
It is configured to operate at 768 MHz and for by channel coefficient operation. This takes 17 DSP slices. The
channel configuration is streamed in 0,1,2,3... from a simple VHDL block. The reload channel is an input to the
subsystem. TUSER is passed through.

## Trigger

# Capture
Debugging and setup of the MKID readout requires capturing raw data from various points in the processing pipeline. AXI4S broadcasters are used in various hierarchies to tap into and route data streams to the capture subsystem, key cores are  `pair_iq` (for raw ADC capture), `filter_iq` (for capturing IQ samples), or `filter_phase` (for capturing phase samples) (all [here](https://github.com/MazinLab/iq-capture)). A stream switch is used to pick between streams and feed one to Dan Gisselquist's lovely `axis2mm` (`./blocks/wb2axip/axis2mm.v`) verilog core to generate the AXI write transactions to PL DDR4. The subsystem uses the [capture_upsizer](https://github.com/MazinLab/captur-upsizer) HLS block to upsize from a 256b to 512b AXI4S stream after the switch. A customized version of Xilinx's AXI4S Interconnect ("JebConnect") is used to ensure that there is sufficient buffering to handle MIG auto-refresh cycles. The resulting capture system is capable of capturing at a sustained 16.384 GiB/s. 

![](./img/capture.png)
